"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLatestBuildAsync = exports.listAndSelectBuildsOnAppAsync = exports.listAndRenderBuildsOnAppAsync = exports.BUILDS_LIMIT = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const BuildQuery_1 = require("../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importDefault(require("../log"));
const platform_1 = require("../platform");
const prompts_1 = require("../prompts");
const json_1 = require("../utils/json");
const queries_1 = require("../utils/queries");
const formatBuild_1 = require("./utils/formatBuild");
exports.BUILDS_LIMIT = 50;
async function listAndRenderBuildsOnAppAsync(graphqlClient, { projectId, projectDisplayName, filter, paginatedQueryOptions, }) {
    var _a, _b;
    if (paginatedQueryOptions.nonInteractive) {
        const builds = await BuildQuery_1.BuildQuery.viewBuildsOnAppAsync(graphqlClient, {
            appId: projectId,
            limit: (_a = paginatedQueryOptions.limit) !== null && _a !== void 0 ? _a : exports.BUILDS_LIMIT,
            offset: paginatedQueryOptions.offset,
            filter,
        });
        renderPageOfBuilds({ builds, projectDisplayName, paginatedQueryOptions });
    }
    else {
        await (0, queries_1.paginatedQueryWithConfirmPromptAsync)({
            limit: (_b = paginatedQueryOptions.limit) !== null && _b !== void 0 ? _b : exports.BUILDS_LIMIT,
            offset: paginatedQueryOptions.offset,
            queryToPerform: (limit, offset) => BuildQuery_1.BuildQuery.viewBuildsOnAppAsync(graphqlClient, {
                appId: projectId,
                limit,
                offset,
                filter,
            }),
            promptOptions: {
                title: 'Load more builds?',
                renderListItems: builds => renderPageOfBuilds({ builds, projectDisplayName, paginatedQueryOptions }),
            },
        });
    }
}
exports.listAndRenderBuildsOnAppAsync = listAndRenderBuildsOnAppAsync;
async function listAndSelectBuildsOnAppAsync(graphqlClient, { projectId, projectDisplayName, filter, queryOptions, }) {
    var _a;
    const builds = await BuildQuery_1.BuildQuery.viewBuildsOnAppAsync(graphqlClient, {
        appId: projectId,
        limit: (_a = queryOptions.limit) !== null && _a !== void 0 ? _a : exports.BUILDS_LIMIT,
        offset: queryOptions.offset,
        filter,
    });
    if (builds.length === 0) {
        throw new Error('Found no builds matching the provided criteria.');
    }
    const { selectedSimulatorBuild } = await (0, prompts_1.promptAsync)({
        type: 'select',
        message: `Select simulator build to run for ${projectDisplayName} app`,
        name: 'selectedSimulatorBuild',
        choices: builds.map(build => ({
            title: `id: ${build.id}, platform: ${platform_1.appPlatformDisplayNames[build.platform]}, version: ${build.appVersion}, build number: ${build.appBuildVersion}`,
            value: build,
        })),
    });
    return selectedSimulatorBuild;
}
exports.listAndSelectBuildsOnAppAsync = listAndSelectBuildsOnAppAsync;
async function getLatestBuildAsync(graphqlClient, { projectId, filter, }) {
    const builds = await BuildQuery_1.BuildQuery.viewBuildsOnAppAsync(graphqlClient, {
        appId: projectId,
        limit: 1,
        offset: 0,
        filter,
    });
    if (builds.length === 0) {
        throw new Error('Found no build matching the provided criteria.');
    }
    return builds[0];
}
exports.getLatestBuildAsync = getLatestBuildAsync;
function renderPageOfBuilds({ builds, projectDisplayName, paginatedQueryOptions, }) {
    if (paginatedQueryOptions.json) {
        (0, json_1.printJsonOnlyOutput)(builds);
    }
    else {
        const list = builds.map(build => (0, formatBuild_1.formatGraphQLBuild)(build)).join(`\n\n${chalk_1.default.dim('———')}\n\n`);
        log_1.default.addNewLineIfNone();
        log_1.default.log(chalk_1.default.bold(`Builds for ${projectDisplayName}:`));
        log_1.default.log(`\n${list}`);
    }
}
