"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAppFromLocalArchiveAsync = exports.downloadAndExtractAppAsync = void 0;
const tslib_1 = require("tslib");
const spawn_async_1 = tslib_1.__importDefault(require("@expo/spawn-async"));
const cli_progress_1 = tslib_1.__importDefault(require("cli-progress"));
const fast_glob_1 = tslib_1.__importDefault(require("fast-glob"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const stream_1 = require("stream");
const tar_1 = require("tar");
const util_1 = require("util");
const uuid_1 = require("uuid");
const fetch_1 = tslib_1.__importDefault(require("../fetch"));
const log_1 = tslib_1.__importDefault(require("../log"));
const paths_1 = require("./paths");
const pipeline = (0, util_1.promisify)(stream_1.Stream.pipeline);
function wrapFetchWithProgress() {
    return async (url, init, onProgressCallback) => {
        const response = await (0, fetch_1.default)(url, init);
        if (response.ok) {
            const totalDownloadSize = response.headers.get('Content-Length');
            const total = Number(totalDownloadSize);
            if (!totalDownloadSize || isNaN(total) || total < 0) {
                log_1.default.warn('Progress callback not supported for network request because "Content-Length" header missing or invalid in response from URL:', url.toString());
                return response;
            }
            let length = 0;
            const onProgress = (chunkLength) => {
                if (chunkLength) {
                    length += chunkLength;
                }
                const progress = length / total;
                onProgressCallback(progress, total, length);
            };
            response.body.on('data', chunk => {
                onProgress(chunk.length);
            });
            response.body.on('end', () => {
                onProgress();
            });
        }
        return response;
    };
}
async function downloadFileWithProgressBarAsync(url, outputPath, infoMessage) {
    log_1.default.newLine();
    log_1.default.log(infoMessage ? infoMessage : `Downloading file from ${url}...`);
    const downloadProgressBar = new cli_progress_1.default.SingleBar({ format: '|{bar}|' }, cli_progress_1.default.Presets.rect);
    let downloadProgressBarStarted = false;
    const response = await wrapFetchWithProgress()(url, {
        timeout: 1000 * 60 * 5, // 5 minutes
    }, (_progress, total, loaded) => {
        if (!downloadProgressBarStarted) {
            downloadProgressBar.start(total, loaded);
            downloadProgressBarStarted = true;
        }
        else if (loaded < total) {
            downloadProgressBar.update(loaded);
        }
        else {
            downloadProgressBar.stop();
        }
    });
    if (!response.ok) {
        throw new Error(`Failed to download file from ${url}`);
    }
    await pipeline(response.body, fs_1.default.createWriteStream(outputPath));
}
async function downloadAndExtractAppAsync(url, applicationExtension) {
    const outputDir = path_1.default.join((0, paths_1.getTmpDirectory)(), (0, uuid_1.v4)());
    await fs_1.default.promises.mkdir(outputDir, { recursive: true });
    const tmpArchivePathDir = path_1.default.join((0, paths_1.getTmpDirectory)(), (0, uuid_1.v4)());
    await fs_1.default.promises.mkdir(tmpArchivePathDir, { recursive: true });
    const tmpArchivePath = path_1.default.join(tmpArchivePathDir, `${(0, uuid_1.v4)()}.tar.gz`);
    await downloadFileWithProgressBarAsync(url, tmpArchivePath, 'Downloading app archive...');
    await tarExtractAsync(tmpArchivePath, outputDir);
    return await getAppPathAsync(outputDir, applicationExtension);
}
exports.downloadAndExtractAppAsync = downloadAndExtractAppAsync;
async function extractAppFromLocalArchiveAsync(appArchivePath, applicationExtension) {
    const outputDir = path_1.default.join((0, paths_1.getTmpDirectory)(), (0, uuid_1.v4)());
    await fs_1.default.promises.mkdir(outputDir, { recursive: true });
    await tarExtractAsync(appArchivePath, outputDir);
    return await getAppPathAsync(outputDir, applicationExtension);
}
exports.extractAppFromLocalArchiveAsync = extractAppFromLocalArchiveAsync;
async function getAppPathAsync(outputDir, applicationExtension) {
    const appFileName = await (0, fast_glob_1.default)(`*.${applicationExtension}`, {
        cwd: outputDir,
        onlyFiles: false,
    });
    if (appFileName.length === 0) {
        throw Error('Something went wrong while extracting the app from app archive');
    }
    return path_1.default.join(outputDir, appFileName[0]);
}
async function tarExtractAsync(input, output) {
    try {
        if (process.platform !== 'win32') {
            await (0, spawn_async_1.default)('tar', ['-xf', input, '-C', output], {
                stdio: 'inherit',
            });
            return;
        }
    }
    catch (error) {
        log_1.default.warn(`Failed to extract tar using native tools, falling back on JS tar module. ${error.message}`);
    }
    log_1.default.debug(`Extracting ${input} to ${output} using JS tar module`);
    // tar node module has previously had problems with big files, and seems to
    // be slower, so only use it as a backup.
    await (0, tar_1.extract)({ file: input, cwd: output });
}
