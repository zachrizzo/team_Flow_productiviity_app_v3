"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPublishPlatforms = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const queries_1 = require("../../branch/queries");
const utils_1 = require("../../branch/utils");
const url_1 = require("../../build/utils/url");
const queries_2 = require("../../channel/queries");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const pagination_1 = require("../../commandUtils/pagination");
const fetch_1 = tslib_1.__importDefault(require("../../fetch"));
const generated_1 = require("../../graphql/generated");
const PublishMutation_1 = require("../../graphql/mutations/PublishMutation");
const UpdateQuery_1 = require("../../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importStar(require("../../log"));
const ora_1 = require("../../ora");
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const publish_1 = require("../../project/publish");
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const configure_1 = require("../../update/configure");
const queries_3 = require("../../update/queries");
const utils_2 = require("../../update/utils");
const code_signing_1 = require("../../utils/code-signing");
const uniqBy_1 = tslib_1.__importDefault(require("../../utils/expodash/uniqBy"));
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
const statuspageService_1 = require("../../utils/statuspageService");
const vcs_1 = require("../../vcs");
exports.defaultPublishPlatforms = ['android', 'ios'];
function getRequestedPlatform(platform) {
    switch (platform) {
        case 'android':
            return platform_1.RequestedPlatform.Android;
        case 'ios':
            return platform_1.RequestedPlatform.Ios;
        case 'web':
            return null;
        case 'all':
            return platform_1.RequestedPlatform.All;
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }
}
class UpdatePublish extends EasCommand_1.default {
    async runAsync() {
        var _b, _c, _d;
        const { flags: rawFlags } = await this.parse(UpdatePublish);
        const paginatedQueryOptions = (0, pagination_1.getPaginatedQueryOptions)(rawFlags);
        let { auto: autoFlag, platform: platformFlag, branchName, updateMessage, republish, groupId, inputDir, skipBundler, privateKeyPath, json: jsonFlag, nonInteractive, } = this.sanitizeFlags(rawFlags);
        const { getDynamicProjectConfigAsync, loggedIn: { graphqlClient }, } = await this.getContextAsync(UpdatePublish, {
            nonInteractive,
        });
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const { exp: expPossiblyWithoutEasUpdateConfigured, projectId, projectDir, } = await getDynamicProjectConfigAsync({
            isPublicConfig: true,
        });
        const { exp: expPrivate } = await getDynamicProjectConfigAsync({
            isPublicConfig: false,
        });
        await (0, statuspageService_1.maybeWarnAboutEasOutagesAsync)(graphqlClient, [generated_1.StatuspageServiceName.EasUpdate]);
        await (0, configure_1.ensureEASUpdatesIsConfiguredAsync)(graphqlClient, {
            exp: expPossiblyWithoutEasUpdateConfigured,
            platform: getRequestedPlatform(platformFlag),
            projectDir,
            projectId,
        });
        const { exp } = await getDynamicProjectConfigAsync();
        const codeSigningInfo = await (0, code_signing_1.getCodeSigningInfoAsync)(expPrivate, privateKeyPath);
        let realizedPlatforms = [];
        if (!branchName) {
            if (autoFlag) {
                branchName = await (0, utils_1.getDefaultBranchNameAsync)();
            }
            else if (nonInteractive) {
                throw new Error('Must supply --branch or use --auto when in non-interactive mode');
            }
            else {
                try {
                    const branch = await (0, queries_1.selectBranchOnAppAsync)(graphqlClient, {
                        projectId,
                        promptTitle: `Which branch would you like to ${republish ? 'republish' : 'publish'} on?`,
                        displayTextForListItem: updateBranch => `${updateBranch.name} ${chalk_1.default.grey(`- current update: ${(0, utils_2.formatUpdateMessage)(updateBranch.updates[0])}`)}`,
                        paginatedQueryOptions,
                    });
                    branchName = branch.name;
                }
                catch {
                    // unable to select a branch (network error or no branches for project)
                    ({ name: branchName } = await (0, prompts_1.promptAsync)({
                        type: 'text',
                        name: 'name',
                        message: 'No branches found. Provide a branch name:',
                        initial: await (0, utils_1.getDefaultBranchNameAsync)(),
                        validate: value => (value ? true : 'Branch name may not be empty.'),
                    }));
                }
                (0, assert_1.default)(branchName, 'Branch name must be specified.');
            }
        }
        let unsortedUpdateInfoGroups = {};
        let oldMessage, oldRuntimeVersion;
        let uploadedAssetCount = 0;
        let assetLimitPerUpdateGroup = 0;
        if (republish) {
            // If we are republishing, we don't need to worry about building the bundle or uploading the assets.
            // Instead we get the `updateInfoGroup` from the update we wish to republish.
            let updatesToRepublish;
            if (groupId) {
                const updatesByGroup = await UpdateQuery_1.UpdateQuery.viewUpdateGroupAsync(graphqlClient, {
                    groupId,
                });
                updatesToRepublish = updatesByGroup;
            }
            else {
                if (nonInteractive) {
                    throw new Error('Must supply --group when in non-interactive mode');
                }
                updatesToRepublish = await (0, queries_3.selectUpdateGroupOnBranchAsync)(graphqlClient, {
                    projectId,
                    branchName,
                    paginatedQueryOptions,
                });
            }
            const updatesToRepublishFilteredByPlatform = updatesToRepublish.filter(
            // Only republish to the specified platforms
            update => platformFlag === 'all' || update.platform === platformFlag);
            if (updatesToRepublishFilteredByPlatform.length === 0) {
                throw new Error(`There are no updates on branch "${branchName}" published for the platform(s) "${platformFlag}" with group ID "${groupId ? groupId : updatesToRepublish[0].group}". Did you mean to publish a new update instead?`);
            }
            let publicationPlatformMessage;
            if (platformFlag === 'all') {
                if (updatesToRepublishFilteredByPlatform.length < exports.defaultPublishPlatforms.length) {
                    log_1.default.warn(`You are republishing an update that wasn't published for all platforms.`);
                }
                publicationPlatformMessage = `The republished update will appear on the same platforms it was originally published on: ${updatesToRepublishFilteredByPlatform
                    .map(update => update.platform)
                    .join(', ')}`;
            }
            else {
                publicationPlatformMessage = `The republished update will appear only on: ${platformFlag}`;
            }
            log_1.default.withTick(publicationPlatformMessage);
            for (const update of updatesToRepublishFilteredByPlatform) {
                const { manifestFragment } = update;
                const platform = update.platform;
                unsortedUpdateInfoGroups[platform] = JSON.parse(manifestFragment);
            }
            realizedPlatforms = updatesToRepublishFilteredByPlatform.map(update => update.platform);
            // These are the same for each member of an update group
            groupId = updatesToRepublishFilteredByPlatform[0].group;
            oldMessage = (_b = updatesToRepublishFilteredByPlatform[0].message) !== null && _b !== void 0 ? _b : '';
            oldRuntimeVersion = updatesToRepublishFilteredByPlatform[0].runtimeVersion;
            if (!updateMessage) {
                if (nonInteractive) {
                    throw new Error('Must supply --message when in non-interactive mode');
                }
                const validationMessage = 'publish message may not be empty.';
                if (jsonFlag) {
                    throw new Error(validationMessage);
                }
                ({ updateMessage } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'updateMessage',
                    message: `Provide an update message.`,
                    initial: `Republish "${oldMessage}" - group: ${groupId}`,
                    validate: (value) => (value ? true : validationMessage),
                }));
            }
        }
        else {
            if (!updateMessage && autoFlag) {
                updateMessage = (_c = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _c === void 0 ? void 0 : _c.trim();
            }
            if (!updateMessage) {
                if (nonInteractive) {
                    throw new Error('Must supply --message or use --auto when in non-interactive mode');
                }
                const validationMessage = 'publish message may not be empty.';
                if (jsonFlag) {
                    throw new Error(validationMessage);
                }
                ({ updateMessage } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'updateMessage',
                    message: `Provide an update message.`,
                    initial: (_d = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _d === void 0 ? void 0 : _d.trim(),
                    validate: (value) => (value ? true : validationMessage),
                }));
            }
            // build bundle and upload assets for a new publish
            if (!skipBundler) {
                const bundleSpinner = (0, ora_1.ora)().start('Exporting...');
                try {
                    await (0, publish_1.buildBundlesAsync)({ projectDir, inputDir, exp, platformFlag });
                    bundleSpinner.succeed('Exported bundle(s)');
                }
                catch (e) {
                    bundleSpinner.fail('Export failed');
                    throw e;
                }
            }
            // After possibly bundling, assert that the input directory can be found.
            const distRoot = await (0, publish_1.resolveInputDirectoryAsync)(inputDir, { skipBundler });
            const assetSpinner = (0, ora_1.ora)().start('Uploading...');
            try {
                const collectedAssets = await (0, publish_1.collectAssetsAsync)(distRoot);
                const assets = (0, publish_1.filterExportedPlatformsByFlag)(collectedAssets, platformFlag);
                realizedPlatforms = Object.keys(assets);
                const uploadResults = await (0, publish_1.uploadAssetsAsync)(graphqlClient, assets, projectId, (totalAssets, missingAssets) => {
                    assetSpinner.text = `Uploading (${totalAssets - missingAssets}/${totalAssets})`;
                });
                uploadedAssetCount = uploadResults.uniqueUploadedAssetCount;
                assetLimitPerUpdateGroup = uploadResults.assetLimitPerUpdateGroup;
                unsortedUpdateInfoGroups = await (0, publish_1.buildUnsortedUpdateInfoGroupAsync)(assets, exp);
                const uploadAssetSuccessMessage = uploadedAssetCount
                    ? `Uploaded ${uploadedAssetCount} ${uploadedAssetCount === 1 ? 'platform' : 'platforms'}`
                    : `Uploaded: No changes detected`;
                assetSpinner.succeed(uploadAssetSuccessMessage);
            }
            catch (e) {
                assetSpinner.fail('Failed to upload');
                throw e;
            }
        }
        const truncatedMessage = (0, utils_2.truncateString)(updateMessage, 1024);
        if (truncatedMessage !== updateMessage) {
            log_1.default.warn('Update message exceeds the allowed 1024 character limit. Truncating message...');
        }
        const runtimeVersions = await getRuntimeVersionObjectAsync(exp, realizedPlatforms, projectDir);
        const runtimeToPlatformMapping = [];
        for (const runtime of runtimeVersions) {
            const platforms = runtimeVersions
                .filter(({ runtimeVersion }) => runtimeVersion === runtime.runtimeVersion)
                .map(({ platform }) => platform);
            if (!runtimeToPlatformMapping.find(item => item.runtimeVersion === runtime.runtimeVersion)) {
                runtimeToPlatformMapping.push({ runtimeVersion: runtime.runtimeVersion, platforms });
            }
        }
        const { branchId } = await (0, queries_1.ensureBranchExistsAsync)(graphqlClient, {
            appId: projectId,
            branchName,
        });
        await (0, queries_2.ensureChannelExistsAsync)(graphqlClient, {
            appId: projectId,
            branchId,
            channelName: branchName,
        });
        log_1.default.withTick(`Channel: ${chalk_1.default.bold(branchName)} pointed at branch: ${chalk_1.default.bold(branchName)}`);
        const gitCommitHash = await (0, vcs_1.getVcsClient)().getCommitHashAsync();
        // Sort the updates into different groups based on their platform specific runtime versions
        const updateGroups = runtimeToPlatformMapping.map(({ runtimeVersion, platforms }) => {
            const localUpdateInfoGroup = Object.fromEntries(platforms.map(platform => [
                platform,
                unsortedUpdateInfoGroups[platform],
            ]));
            if (republish && !oldRuntimeVersion) {
                throw new Error('Cannot find the runtime version of the update group that is being republished.');
            }
            return {
                branchId,
                updateInfoGroup: localUpdateInfoGroup,
                runtimeVersion: republish ? oldRuntimeVersion : runtimeVersion,
                message: truncatedMessage,
                gitCommitHash,
                awaitingCodeSigningInfo: !!codeSigningInfo,
            };
        });
        let newUpdates;
        const publishSpinner = (0, ora_1.ora)('Publishing...').start();
        try {
            newUpdates = await PublishMutation_1.PublishMutation.publishUpdateGroupAsync(graphqlClient, updateGroups);
            if (codeSigningInfo) {
                log_1.default.log('🔒 Signing updates');
                const updatesTemp = [...newUpdates];
                const updateGroupsAndTheirUpdates = updateGroups.map(updateGroup => {
                    const newUpdates = updatesTemp.splice(0, Object.keys(updateGroup.updateInfoGroup).length);
                    return {
                        updateGroup,
                        newUpdates,
                    };
                });
                await Promise.all(updateGroupsAndTheirUpdates.map(async ({ updateGroup, newUpdates }) => {
                    await Promise.all(newUpdates.map(async (newUpdate) => {
                        const response = await (0, fetch_1.default)(newUpdate.manifestPermalink, {
                            method: 'GET',
                            headers: { accept: 'multipart/mixed' },
                        });
                        const manifestBody = (0, nullthrows_1.default)(await (0, code_signing_1.getManifestBodyAsync)(response));
                        (0, code_signing_1.checkManifestBodyAgainstUpdateInfoGroup)(manifestBody, (0, nullthrows_1.default)(updateGroup.updateInfoGroup[newUpdate.platform]));
                        const manifestSignature = (0, code_signing_1.signManifestBody)(manifestBody, codeSigningInfo);
                        await PublishMutation_1.PublishMutation.setCodeSigningInfoAsync(graphqlClient, newUpdate.id, {
                            alg: codeSigningInfo.codeSigningMetadata.alg,
                            keyid: codeSigningInfo.codeSigningMetadata.keyid,
                            sig: manifestSignature,
                        });
                    }));
                }));
            }
            publishSpinner.succeed('Published!');
        }
        catch (e) {
            publishSpinner.fail('Failed to publish updates');
            throw e;
        }
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(newUpdates);
        }
        else {
            if (new Set(newUpdates.map(update => update.group)).size > 1) {
                log_1.default.addNewLineIfNone();
                log_1.default.log('👉 Since multiple runtime versions are defined, multiple update groups have been published.');
            }
            log_1.default.addNewLineIfNone();
            for (const runtime of (0, uniqBy_1.default)(runtimeVersions, version => version.runtimeVersion)) {
                const newUpdatesForRuntimeVersion = newUpdates.filter(update => update.runtimeVersion === runtime.runtimeVersion);
                if (newUpdatesForRuntimeVersion.length === 0) {
                    throw new Error(`Publish response is missing updates with runtime ${runtime.runtimeVersion}.`);
                }
                const platforms = newUpdatesForRuntimeVersion.map(update => update.platform);
                const newAndroidUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'android');
                const newIosUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'ios');
                const updateGroupId = newUpdatesForRuntimeVersion[0].group;
                const projectName = exp.slug;
                const accountName = (await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId)).name;
                const updateGroupUrl = (0, url_1.getUpdateGroupUrl)(accountName, projectName, updateGroupId);
                const updateGroupLink = (0, log_1.link)(updateGroupUrl, { dim: false });
                log_1.default.log((0, formatFields_1.default)([
                    { label: 'Branch', value: branchName },
                    { label: 'Runtime version', value: runtime.runtimeVersion },
                    { label: 'Platform', value: platforms.join(', ') },
                    { label: 'Update group ID', value: updateGroupId },
                    ...(newAndroidUpdate
                        ? [{ label: 'Android update ID', value: newAndroidUpdate.id }]
                        : []),
                    ...(newIosUpdate ? [{ label: 'iOS update ID', value: newIosUpdate.id }] : []),
                    { label: 'Message', value: truncatedMessage },
                    ...(gitCommitHash ? [{ label: 'Commit', value: gitCommitHash }] : []),
                    { label: 'Website link', value: updateGroupLink },
                ]));
                log_1.default.addNewLineIfNone();
                if ((0, publish_1.isUploadedAssetCountAboveWarningThreshold)(uploadedAssetCount, assetLimitPerUpdateGroup)) {
                    log_1.default.warn(`This update group contains ${uploadedAssetCount} assets and is nearing the server cap of ${assetLimitPerUpdateGroup}.\n` +
                        `${(0, log_1.learnMore)('https://docs.expo.dev/eas-update/optimize-assets/', {
                            learnMoreMessage: 'Consider optimizing your usage of assets',
                            dim: false,
                        })}.`);
                    log_1.default.addNewLineIfNone();
                }
            }
        }
    }
    sanitizeFlags(flags) {
        var _b, _c;
        const nonInteractive = (_b = flags['non-interactive']) !== null && _b !== void 0 ? _b : false;
        const { auto, branch: branchName, message: updateMessage } = flags;
        if (nonInteractive && !auto && !(branchName && updateMessage)) {
            core_1.Errors.error('--auto or both --branch and --message are required when updating in non-interactive mode', { exit: 1 });
        }
        const groupId = flags.group;
        const republish = flags.republish || !!groupId; // When --group is defined, we are republishing
        if (nonInteractive && republish && !groupId) {
            core_1.Errors.error(`--group is required when updating in non-interactive mode`, { exit: 1 });
        }
        return {
            auto,
            branchName,
            updateMessage,
            groupId,
            republish,
            inputDir: flags['input-dir'],
            skipBundler: flags['skip-bundler'],
            platform: flags.platform,
            privateKeyPath: flags['private-key-path'],
            nonInteractive,
            json: (_c = flags.json) !== null && _c !== void 0 ? _c : false,
        };
    }
}
exports.default = UpdatePublish;
_a = UpdatePublish;
UpdatePublish.description = 'publish an update group';
UpdatePublish.flags = {
    branch: core_1.Flags.string({
        description: 'Branch to publish the update group on',
        required: false,
    }),
    message: core_1.Flags.string({
        description: 'A short message describing the update',
        required: false,
    }),
    republish: core_1.Flags.boolean({
        description: 'Republish an update group',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    group: core_1.Flags.string({
        description: 'Update group to republish',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    'input-dir': core_1.Flags.string({
        description: 'Location of the bundle',
        default: 'dist',
        required: false,
    }),
    'skip-bundler': core_1.Flags.boolean({
        description: `Skip running Expo CLI to bundle the app before publishing`,
        default: false,
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: [
            // TODO: Add web when it's fully supported
            ...exports.defaultPublishPlatforms,
            'all',
        ],
        default: 'all',
        required: false,
    }),
    auto: core_1.Flags.boolean({
        description: 'Use the current git branch and commit message for the EAS branch and update message',
        default: false,
    }),
    'private-key-path': core_1.Flags.string({
        description: `File containing the PEM-encoded private key corresponding to the certificate in expo-updates' configuration. Defaults to a file named "private-key.pem" in the certificate's directory.`,
        required: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
UpdatePublish.contextDefinition = {
    ..._a.ContextOptions.DynamicProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
/** Get runtime versions grouped by platform. Runtime version is always `null` on web where the platform is always backwards compatible. */
async function getRuntimeVersionObjectAsync(exp, platforms, projectDir) {
    var _b, _c;
    for (const platform of platforms) {
        if (platform === 'web') {
            continue;
        }
        const isPolicy = typeof ((_c = (_b = exp[platform]) === null || _b === void 0 ? void 0 : _b.runtimeVersion) !== null && _c !== void 0 ? _c : exp.runtimeVersion) === 'object';
        if (isPolicy) {
            const isManaged = (await (0, workflow_1.resolveWorkflowAsync)(projectDir, platform)) === eas_build_job_1.Workflow.MANAGED;
            if (!isManaged) {
                throw new Error('Runtime version policies are only supported in the managed workflow. In the bare workflow, runtime version needs to be set manually.');
            }
        }
    }
    return [...new Set(platforms)].map(platform => {
        if (platform === 'web') {
            return { platform: 'web', runtimeVersion: 'UNVERSIONED' };
        }
        return {
            platform,
            runtimeVersion: (0, nullthrows_1.default)(config_plugins_1.Updates.getRuntimeVersion(exp, platform), `Unable to determine runtime version for ${platform_1.requestedPlatformDisplayNames[platform]}. ${(0, log_1.learnMore)('https://docs.expo.dev/eas-update/runtime-versions/')}`),
        };
    });
}
