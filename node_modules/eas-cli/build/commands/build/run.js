"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs_extra_1 = require("fs-extra");
const node_assert_1 = tslib_1.__importDefault(require("node:assert"));
const queries_1 = require("../../build/queries");
const types_1 = require("../../build/types");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const pagination_1 = require("../../commandUtils/pagination");
const generated_1 = require("../../graphql/generated");
const BuildQuery_1 = require("../../graphql/queries/BuildQuery");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const run_1 = require("../../run/run");
const buildDistribution_1 = require("../../utils/buildDistribution");
const download_1 = require("../../utils/download");
class Run extends EasCommand_1.default {
    async runAsync() {
        const { flags: rawFlags } = await this.parse(Run);
        const flags = await this.sanitizeFlagsAsync(rawFlags);
        const queryOptions = (0, pagination_1.getPaginatedQueryOptions)(flags);
        const { loggedIn: { graphqlClient }, projectConfig: { projectId }, } = await this.getContextAsync(Run, {
            nonInteractive: false,
        });
        const simulatorBuildPath = await getPathToSimulatorBuildAppAsync(graphqlClient, projectId, flags, queryOptions);
        await (0, run_1.runAsync)(simulatorBuildPath, flags.selectedPlatform);
    }
    async sanitizeFlagsAsync(flags) {
        const { platform, limit, offset, ...runArchiveFlags } = flags;
        const selectedPlatform = await resolvePlatformAsync(platform);
        if (runArchiveFlags.path &&
            !((runArchiveFlags.path.endsWith('.tar.gz') ||
                runArchiveFlags.path.endsWith('.app') ||
                runArchiveFlags.path.endsWith('.apk')) &&
                (0, fs_extra_1.existsSync)(runArchiveFlags.path))) {
            core_1.Errors.error('The path must point to a .tar.gz archive, .apk file, or .app directory', {
                exit: 1,
            });
        }
        return {
            selectedPlatform,
            runArchiveFlags,
            limit,
            offset,
        };
    }
}
exports.default = Run;
_a = Run;
Run.hidden = true;
Run.description = 'run simulator/emulator builds from eas-cli';
Run.flags = {
    latest: core_1.Flags.boolean({
        description: 'Run the latest simulator/emulator build for specified platform',
        exclusive: ['id', 'path', 'url'],
    }),
    url: core_1.Flags.string({
        description: 'Simulator/Emulator build archive url',
        exclusive: ['latest', 'id', 'path'],
    }),
    path: core_1.Flags.string({
        description: 'Path to the simulator/emulator build archive or simulator build app',
        exclusive: ['latest', 'id', 'url'],
    }),
    id: core_1.Flags.string({
        description: 'ID of the simulator/emulator build to run',
        exclusive: ['latest, path, url'],
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: ['android', 'ios'],
    }),
    ...pagination_1.EasPaginatedQueryFlags,
};
Run.contextDefinition = {
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.ProjectDir,
};
async function resolvePlatformAsync(platform) {
    if (platform && Object.values(generated_1.AppPlatform).includes(platform.toUpperCase())) {
        return platform.toUpperCase();
    }
    const { selectedPlatform } = await (0, prompts_1.promptAsync)({
        type: 'select',
        message: 'Select platform',
        name: 'selectedPlatform',
        choices: [
            { title: 'Android', value: generated_1.AppPlatform.Android },
            { title: 'iOS', value: generated_1.AppPlatform.Ios },
        ],
    });
    return selectedPlatform;
}
async function maybeGetBuildAsync(graphqlClient, flags, projectId, paginatedQueryOptions) {
    if (flags.runArchiveFlags.id) {
        return BuildQuery_1.BuildQuery.byIdAsync(graphqlClient, flags.runArchiveFlags.id);
    }
    else if (!flags.runArchiveFlags.id &&
        !flags.runArchiveFlags.path &&
        !flags.runArchiveFlags.url &&
        !flags.runArchiveFlags.latest) {
        return await (0, queries_1.listAndSelectBuildsOnAppAsync)(graphqlClient, {
            projectId,
            projectDisplayName: await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId),
            filter: {
                platform: flags.selectedPlatform,
                distribution: (0, buildDistribution_1.buildDistributionTypeToGraphQLDistributionType)(types_1.BuildDistributionType.SIMULATOR),
                status: generated_1.BuildStatus.Finished,
            },
            queryOptions: paginatedQueryOptions,
        });
    }
    else if (flags.runArchiveFlags.latest) {
        return await (0, queries_1.getLatestBuildAsync)(graphqlClient, {
            projectId,
            filter: {
                platform: flags.selectedPlatform,
                distribution: (0, buildDistribution_1.buildDistributionTypeToGraphQLDistributionType)(types_1.BuildDistributionType.SIMULATOR),
                status: generated_1.BuildStatus.Finished,
            },
        });
    }
    else {
        return null;
    }
}
async function getPathToSimulatorBuildAppAsync(graphqlClient, projectId, flags, queryOptions) {
    var _b, _c;
    const maybeBuild = await maybeGetBuildAsync(graphqlClient, flags, projectId, queryOptions);
    const appExtension = flags.selectedPlatform === generated_1.AppPlatform.Ios ? 'app' : 'apk';
    if (maybeBuild) {
        if (!((_b = maybeBuild.artifacts) === null || _b === void 0 ? void 0 : _b.applicationArchiveUrl)) {
            throw new Error('Build does not have an application archive url');
        }
        return await (0, download_1.downloadAndExtractAppAsync)(maybeBuild.artifacts.applicationArchiveUrl, appExtension);
    }
    if (flags.runArchiveFlags.url) {
        return await (0, download_1.downloadAndExtractAppAsync)(flags.runArchiveFlags.url, appExtension);
    }
    if ((_c = flags.runArchiveFlags.path) === null || _c === void 0 ? void 0 : _c.endsWith('.tar.gz')) {
        return await (0, download_1.extractAppFromLocalArchiveAsync)(flags.runArchiveFlags.path, appExtension);
    }
    // this should never fail, due to the validation in sanitizeFlagsAsync
    (0, node_assert_1.default)(flags.runArchiveFlags.path);
    return flags.runArchiveFlags.path;
}
